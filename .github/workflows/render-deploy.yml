name: CI/CD - Java API para Render

on:
  push:
    branches:
      - main
      - master

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      APP_BASE_URL: http://localhost:8080  # URL base que o Cypress usará

    steps:
      - name: Checkout código
        uses: actions/checkout@v4

      - name: Configurar JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: maven

      # ---------- TESTES + COVERAGE (gate JaCoCo ≥ 80%) ----------          
      - name: Rodar testes + cobertura (tests + JaCoCo gate)
        run: mvn -B clean verify

      # ---------- UPLOAD RELATÓRIOS (JaCoCo, Surefire/Failsafe) ----------
      - name: Upload JaCoCo (HTML + XML + exec)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-reports-${{ github.run_number }}
          path: |
            target/site/jacoco/**
            target/jacoco.exec
            target/site/jacoco/jacoco.xml
          retention-days: 14
          if-no-files-found: warn
          compression-level: 6

      - name: Upload JUnit/Surefire/Failsafe reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: junit-reports-${{ github.run_number }}
          path: |
            target/surefire-reports/**
            target/failsafe-reports/**
            target/site/surefire-report.html
          retention-days: 14
          if-no-files-found: warn
          compression-level: 6

      # Se o mvn verify falhar (coverage < 80% ou teste quebrado),
      # o job para aqui e NÃO chega no Sonar nem no deploy

      # # ---------- (OPCIONAL) SONARCLOUD ----------
      # # Ative se quiser bloquear por Quality Gate do SonarCloud também.
      # - name: SonarCloud Scan (Quality Gate)
      #   if: ${{ success() && (github.event_name == 'push' || github.event_name == 'pull_request') }}
      #   uses: SonarSource/sonarcloud-github-action@v2
      #   with:
      #     projectBaseDir: .
      #     args: >
      #       -Dsonar.qualitygate.wait=true
      #   env:
      #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      #     SONAR_HOST_URL: https://sonarcloud.io

      # Opcional: esperar pelo Quality Gate e falhar se reprovar
      - name: Esperar Quality Gate (opcional se usar args acima)
        run: echo "Quality Gate verificado via SonarCloud (configurar em args se quiser falhar o build)."

      - name: Remover exemplos padrão do Cypress
        run: |
          rm -rf cypress/e2e/1-getting-started || true
          rm -rf cypress/e2e/2-advanced-examples || true
      
      # ---------- INICIALIZAR APP PARA E2E ----------
      - name: Empacotar JAR (sem re-testar)
        run: mvn -B -DskipTests package

      - name: Iniciar aplicação em background
        run: |
          nohup java -jar target/*.jar > app.log 2>&1 &
          echo $! > app.pid

      - name: Aguardar readiness da aplicação (index.html ou /api/v1/hello)
        run: |
          set -e
          BASE="http://localhost:8080"
          echo "Aguardando aplicação responder em ${BASE} ..."
          for i in {1..60}; do
            CODE_INDEX=$(curl -s -o /dev/null -w "%{http_code}" "${BASE}/index.html" || true)
            CODE_HELLO=$(curl -s -o /dev/null -w "%{http_code}" "${BASE}/api/v1/hello" || true)
            echo "Tentativa $i - /index.html => ${CODE_INDEX}, /api/v1/hello => ${CODE_HELLO}"
            # Aceita 200 para index OU 200 para hello
            if [ "$CODE_INDEX" = "200" ] || [ "$CODE_HELLO" = "200" ]; then
              echo "Aplicação pronta."
              exit 0
            fi
            sleep 2
          done
          echo "A aplicação não respondeu a tempo"; echo "=== app.log (tail) ==="; tail -n 300 app.log || true; exit 1

      # ---------- CYPRESS E2E (FRONTEND) ----------
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Instalar dependências do front (Cypress)
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm i
          fi

      # Define TERM para remover os warnings do tput
      - name: Definir TERM
        run: echo "TERM=xterm-256color" >> $GITHUB_ENV

      - name: Rodar Cypress (headless) com reporter JUnit
        env:
          APP_BASE_URL: ${{ env.APP_BASE_URL }}
        run: |
          mkdir -p cypress/results
          npx cypress run \
            --config baseUrl=$APP_BASE_URL,video=true,screenshotOnRunFailure=true \
            --reporter junit \
            --reporter-options "mochaFile=cypress/results/junit-[hash].xml,toConsole=true" \
            --spec "cypress/e2e/**/*.cy.{js,jsx,ts,tsx}"

      - name: Upload artefatos do Cypress (vídeos/screenshots/resultados)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-artifacts-${{ github.run_number }}
          path: |
            cypress/videos/**
            cypress/screenshots/**
            cypress/results/**/*.xml
          if-no-files-found: warn
          retention-days: 14

      - name: Finalizar aplicação
        if: always()
        run: |
          if [ -f app.pid ]; then
            kill $(cat app.pid) || true
          fi
          sleep 1
          pkill -f "java -jar target" || true
          true

      # ---------- VALIDAÇÃO DO DOCKERFILE (opcional, garante build) ----------
      - name: Build Docker (validação)
        run: docker build -t java-render-api:ci .

      # # ---------- DEPLOY NO RENDER (somente push na main e tudo OK) ----------
      # - name: Disparar deploy no Render
      #   if: success() && github.ref == 'refs/heads/main'
      #   run: |
      #     echo "Chamando Deploy Hook do Render..."
      #     curl -X POST "$RENDER_DEPLOY_HOOK"
      #   env:
      #     RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}
